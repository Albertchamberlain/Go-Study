# 一. 接口

* 接口解释:接口是一组行为规范的定义.
* 接口中只能有方法声明,方法只能有名称、参数、返回值,不能有方法体
* 每个接口中可以有多个方法声明,结构体把接口中 **所有** 方法都重写后,结构体就属于接口类型
* Go语言中接口和结构体之间的关系是传统面向对象中is-like-a的关系
* 定义接口类型关键字是interface

```go
type 接口名 interface{
  方法名(参数列表) 返回值列表
}
```

* 接口可以`继承`接口,且Go语言推荐把接口中方法`拆分`成多个接口

# 二.代码示例

* 接口中声明完方法,结构体重写接口中方法后,编译器认为结构体实现了接口
  * 重写的方法要求必须和接口中方法名称、方法参数(参数名称可以不同)、返回值列表`完全相同`

```go
type People struct {
	name string
	age  int
}

type Live interface {
	run(run int)
}

func (p *People) run(run int) {
	fmt.Println(p.name, "正在跑步,跑了,", run, "米")
}

func main() {
	peo := People{"张三", 17}
	peo.run(100)
}
```

* 如果接口中有多个方法声明,接口体必须重写接口中`全部方法`才任务结构体实现了接口

```go
type People struct {
	name string
	age  int
}

type Live interface {
	run(run int)
	eat()
}

func (p *People) run(run int) {
	fmt.Println(p.name, "正在跑步,跑了,", run, "米")
}
func (p *People) eat() {
	fmt.Println(p.name, "正在吃饭")
}

func main() {
	peo := People{"张三", 17}
	peo.run(100)
}
```

* 接口可以`继承`接口(组合),上面代码可以改写成下面代码

```go
type People struct {
	name string
	age  int
}

type Live interface {
	run(run int)
	Eat
}

type Eat interface {
	eat()
}

func (p *People) run(run int) {
	fmt.Println(p.name, "正在跑步,跑了,", run, "米")
}
func (p *People) eat() {
	fmt.Println(p.name, "正在吃饭")
}

func main() {
	peo := People{"张三", 17}
	peo.run(100)
}
```

