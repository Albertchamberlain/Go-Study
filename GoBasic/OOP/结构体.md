
## 结构体
* Go语言中的结构体和C++结构体有点类似,而Java或C#中类本质就是结构体
* 结构体是值类型
* 结构体定义语法
  * 结构体就是一种自定义类型
    ```
     type 结构体名称 struct{
      名称 类型//成员或属性
    }
    ```


* 结构体可以定义在函数内部或函数外部(与普通变量一样),定义位置影响到结构体的访问范围
* 如果结构体定义在函数外面,结构体名称首字母是否大写影响到结构体是否能跨包访问
* 如果结构体能`跨包`访问,属性`首字母是否大写`影响到属性是否`跨包访问`

```
type People struct {
	Name string
	Age  int
}
```
声明结构体变量

* 由于结构体是`值类型`,所以`声明后就会开辟内存空间`
* 所有成员为类型对应的初始值
```
var peo People
	fmt.Print(peo)//输出:{0 }
	fmt.Printf("%p",&peo)//会打印内存地址值
```

- 可以直接给结构体多个属性赋值,按照结构体中属性的顺序进行赋值,可以省略属性名称

- 明确指定给哪些属性赋值.可以都赋值,也可以只给其中一部分赋值


- 也可以通过结构体变量名称获取到属性进行赋值或查看

- 双等(==)判断结构体中内容是否相等

## 结构题指针

* 由于结构体是`值类型`,在方法传递时希望传递`结构体地址`,可以使用时`结构体指针`完成
* 可以结合`new(T)`函数创建结构体指针



* 如果不想使用new(T)函数,可以直接声明结构体指针并赋值



# 二.判断

* 结构体指针比较的是地址
* (*结构体指针)取出地址中对应的值

```go
	p1 := People{"smallming", 17}
	p2 := People{"smallming", 17}
	fmt.Printf("%p %p\n", &p1, &p2) //输出地址不同
	fmt.Println(p1 == p2)           //输出:true

	p3 := new(People)
	p3 = &People{"smallming", 17}
	//结构体变量不能和指针比较,使用*指针取出地址中值
	fmt.Println(p1 == *p3) //输出:true

	p4 := &People{"smallming", 17}
	//指针比较的是地址
	fmt.Println(p3 == p4) //输出:false
```