# 一.切片

切片我在python中接触过，相当的方便

* 切片的英文名称slice
* 切片:具有可变长度相同类型元素序列.
* 由于长度是`可变`,可以解决数组长度在数据个数不确定情况下浪费内存的问题.
* 切片和数组声明时语法最主要的区别就是`长度`

```go
	var slice []type   //切片  切片不需要说明长度。采用该声明方式且未初始化的切片为空切片。该切片默认为nil，长度为0
	var array [3]type //数组
```

* 切片只声明时为`nil`,没有开辟内存空间,不能直接操作切片,需要`先初始化`
* 注意:切片只能和nil进行判断是否相等

```go
	var slice []string  //切片
	fmt.Println(slice==nil)//输出:true
	fmt.Printf("%p",slice)//输出:0x0
```
使用make()函数来创建切片,但是不是nil,切片已经申请内存空间,当第三个参数容量省略时,默认与长度相同
切片的容量是成倍增加的，当增加到1024时会按照一一定百分比增加

    var slice []type = make([]type,len,cap)

    slice1:= make([]type ,len)
# 二.定义切片

* 通过直接指定初始值定初始化一个切片变量

```go
	names := []string{"algorithm", "算法"}
	fmt.Println(names)
```

* 定义完切片后就可以通过`切片对象[脚标]`取出或修改切片中元素内容.语法和数组相同

# 三.切片是引用类型

* 引用类型在变量之间赋值时传递的是地址.引用类型变量就是这个类型的指针.切片就是引用类型
* 值类型在变量之间赋值时传递的是值的副本
* 修改切片数值，当多个切片共享相同的底层数组时，对每个元素所做的更改将在数组中反映出来
* 切片没有自己的任何数据,它只是底层数组的一个引用
- 对切片所做的任何修改都将反映在底层数组中
- 数组是值类型，而切片是引用类型

```go
	names := []string{"algorithm", "算法"}
	names1 := names
	names1[0] = "法"
	fmt.Println(names, names1)//输出:[张 佳明哥] [张 佳明哥]
	fmt.Printf("%p %p",names,names1)//地址相同
```

# 四.切片的长度与容量
- 切片的容量是从创建切片的索引开始的底层数组中元素的数量
- 切片可以通过len()方法获取长度，可以通过cap()方法获取容量

# 五.append
- 可以向切片中添加一个或多个值，添加后必须s使用切片接收append()函数的返回值

- 如果添加一次添加多个值,且添加后的长度大于扩容一次的大小，容量和长度相等，等到下次添加内容的如果b不超出扩容大小，在现在的基础翻倍

- 也可以把一个切片内容添加到另一个切片里


# 六.通过数组产生切片


* 定义数组后,取出数组中一个片段,这个片段就是切片类型

```go
	names := [3]string{"老张", "佳明哥", "smallming"}
	s := names[0:2]     //包前不包后
	fmt.Printf("%T", s) //输出:[]string
	fmt.Println(s)      //输出:[老张 佳明哥]
```

* 切片是指针,指向数组元素地址,修改切片的内容,`数组的内容会跟随变化`

```go
	names := [3]string{"algo", "rithem", "math"}
	s := names[0:2] //包前不包后
	fmt.Printf("%p %p",s,&names[0])//输出的地址是相同的
	s[0] = "Go语言"
	fmt.Println(s)     //输出:[Go语言 佳明哥]
	fmt.Println(names) //输出:[Go语言 佳明哥 smallming]
```

* 当切片内容在增加时
  * 如果增加后切片的长度没有超出数组,修改切片也是在修改数组
  * 如果增加后切片的长度超出数组,会重新开辟一块空间放切片的内容
  * 通过下面代码也正面了切片中内容存在一块连续空间(和数组一样)

```go
	names := [3]string{"algo", "rithem", "math"}
	s := names[0:2] //包前不包后
	fmt.Printf("%p %p\n",s,&names[0])
	s[0] = "Go语言"
	s=append(s,"yep")
	fmt.Println(s)     //输出:[Go语言 佳明哥 区块链]
	fmt.Println(names) //输出:[Go语言 佳明哥 区块链]
	fmt.Printf("%p %p\n",s,&names[0])//地址相同

	s=append(s,"out of range")
	fmt.Println(s)     //输出:[Go语言 佳明哥 区块链 超出了数组长度]
	fmt.Println(names) //输出:[Go语言 佳明哥 区块链]
	fmt.Printf("%p %p\n",s,&names[0])//切片地址改变
```

# 七.删除实现

## 1.子切片删除
* Go语言标准库中没有提供删除的函数
* 切片也可以取其中的一段形成子切片,利用这个特性可以实现删除效果,本质就是删除底层数组的一部分

```go
	num := []int {0,1,2,3,4,5,6}
	//要删除脚标为n的元素
	n:= 2
	num1 :=num[0:n]
	num1= append(num1,num[n+1:]...)
	fmt.Println(num1)
```

## 使用copy完成删除元素
```
s := []int{1, 2, 3, 4, 5, 6, 7}
	n := 2 //要删除元素的索引
	newSlice := make([]int, n)
	copy(newSlice, s[0:n])
	newSlice = append(newSlice, s[n+1:]...)
	fmt.Println(s)        //原切片不变
	fmt.Println(newSlice) //删除指定元素后的切片
```


# 八.copy函数

- 通过copy函数可以把一个切片内容复制到另一个切片中
- func copy(dst, src []Type) int
`拷贝时严格按照脚标进行拷贝.且不会对目标切片进行扩容` ,也就是说会覆盖对应的值
- 把短切片拷贝到长切片中
- 把长切片拷贝到短切片中
- 把切片片段拷贝到切片中



