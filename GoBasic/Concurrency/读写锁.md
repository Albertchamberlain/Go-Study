
# RWMutexè¯»å†™é”ğŸ”’

* RWMutex æºç å¦‚ä¸‹

```go
type RWMutex struct {
	w           Mutex  // held if there are pending writers
	writerSem   uint32 // semaphore for writers to wait for completing readers
	readerSem   uint32 // semaphore for readers to wait for completing writers
	readerCount int32  // number of pending readers
	readerWait  int32  // number of departing readers
}
```

* Goè¯­è¨€æ ‡å‡†åº“ä¸­APIå¦‚ä¸‹

```go
type RWMutex
  func (rw *RWMutex) Lock()//ç¦æ­¢å…¶ä»–åç¨‹è¯»å†™
  func (rw *RWMutex) Unlock()
  func (rw *RWMutex) RLock()//ç¦æ­¢å…¶ä»–åç¨‹å†™å…¥,åªèƒ½è¯»å–
  func (rw *RWMutex) RUnlock()
  func (rw *RWMutex) RLocker() Locker
```

* Goè¯­è¨€ä¸­çš„`map`ä¸æ˜¯çº¿ç¨‹å®‰å…¨çš„,`å¤šä¸ªgoroutine`åŒæ—¶æ“ä½œä¼šå‡ºç°é”™è¯¯.
* RWMutexå¯ä»¥æ·»åŠ å¤šä¸ªè¯»é”æˆ–ä¸€ä¸ªå†™é”.è¯»å†™é”ä¸èƒ½åŒæ—¶å­˜åœ¨.
  * mapåœ¨å¹¶å‘ä¸‹è¯»å†™å°±éœ€è¦ç»“åˆè¯»å†™é”å®Œæˆ
  * äº’æ–¥é”è¡¨ç¤ºé”çš„ä»£ç åŒä¸€æ—¶é—´åªèƒ½æœ‰ä¸€ä¸ªäººgoroutineè¿è¡Œ,è€Œè¯»å†™é”è¡¨ç¤ºåœ¨é”èŒƒå›´å†…æ•°æ®çš„è¯»å†™æ“ä½œ

```go
package main

import (
   "fmt"
   "sync"
   "strconv"
)

func main() {
   var rwm sync.RWMutex
   m := make(map[string]string)
   var wg sync.WaitGroup
   wg.Add(10)
   for i := 0; i < 10; i++ {
      go func(j int) {
         //æ²¡æœ‰é”åœ¨mapæ—¶å¯èƒ½å‡ºç°é—®é¢˜
         rwm.Lock()
         m["key"+strconv.Itoa(j)] = "value" + strconv.Itoa(j)
         fmt.Println(m)
         rwm.Unlock()
         wg.Done()
      }(i)
   }
   wg.Wait()
   fmt.Println("ç¨‹åºç»“æŸ")
}
```