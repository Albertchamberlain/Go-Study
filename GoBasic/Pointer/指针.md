# 指针

## 变量地址

```
func main() {
	a := 3
	fmt.Println(&a) //输出:地址
	a = 4
	fmt.Println(&a) //输出的地址不变

	b := a
	b = 5
	fmt.Println(&b, &a) //两个值不相同
	fmt.Println(b, a)   //输出:5 4
}
```

* 每次对变量重新赋值就是在修改变量地址中的内容
* 在Go语言中可以通过 `&+变量名` 获取到变量地址值
* 重新创建一个非引用型变量(即使是把已有变量直接赋值给新变量)也会新开辟内存地址.

go的指针理解起来与C++十分相似，在此就不做赘述了 不过也有一下不同点

golang中的数组是这样说的: Arrays are values, not implicit pointers as in
C.


- 数组做参数时, 需要被检查长度.
- 变量名不等于数组开始指针!
- 不支持C中的*(ar + sizeof(int))方式的指针移动. 需要使用到`unsafe`包
- 如果p2array为指向数组的指针， *p2array不等于p2array[0]

unsafe包在java中也存在（Sun包下面），直接操作内存，对于新手来说直接操作内存的确非常危险


## 指针变量

* 指针变量指向一个值的内存地址
* 使用&+变量 返回值就是一个指针类型
* 使用`var 变量名 *类型` 声明指针类型变量
* 声明指针不会开辟内存地址,只是准备要指向内存某个空间,而声明变量会开辟内存地址,准备存放内容.所以指针类型变量都是把一个变量的地址赋值给指针变量
* 使用`*+指针`能够获取内存地址中的值.所以`*+指针`就和直接使用变量是相同的
* 应用指针可以实现多个地方操作同一个内存地址的值(在方法参数应用指针较多)

```
func main() {
	//创建变量
	a := 123
	var point *int
	point = &a //此时point和&a是相等的
	fmt.Println(point)
	*point = 3             //等价于a=3
	fmt.Println(*point, a) //*point和a是相当的
}
```

## 空指针

* 指针目的就是指向内存中一块地址
* 声明指针后指针不会指向任何内存地址,所以此时指针是空.在Go语言中空用nil表示

```
func main() {
	var a *int
	fmt.Println(a)        //输出:<nil>
	fmt.Println(a == nil) //输出true
}
```

## new

可以通过new函数直接创建指针 变量名 :=new(Type)
